// ===================================================
// This file is part of the Kulfon compiler.
// Author: Rafał Równiak
// License: Read LICENSE file
// Created on: 28.06.2025
// ---------------------------------------------------
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=kf_lex.def");
    let dest_path = Path::new("src").join("lex_def.rs");
    generate_lex_grammar(include_str!("kf_lex.def"), &dest_path);
}

fn generate_lex_grammar(input: &str, output_f: &Path) {
    let mut variants = Vec::new();
    let mut from_literal = Vec::new();
    let mut kinds = Vec::new();
    let mut categories = std::collections::HashMap::new();

    for line in input.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() != 3 {
            panic!("Invalid line: {}", line);
        }

        let kind = parts[0];
        let literal = parts[1];
        let enum_name = parts[2];

        variants.push(enum_name.to_string());
        from_literal.push((literal.to_string(), enum_name.to_string()));
        kinds.push(kind.to_string());
        categories
            .entry(kind.to_string())
            .or_insert_with(Vec::new)
            .push(enum_name.to_string());
    }

    let mut output = String::new();

    // Enum definition
    output.push_str("// DO NOT EDIT: This file is auto-generated by build.rs\n\n");
    output.push_str("// Lexical grammar definition for Kulfon language\n\n");
    output.push_str("#[derive(Debug, PartialEq, Eq, Clone)]\n");
    output.push_str("pub enum KfTokKind {\n");
    for v in &variants {
        output.push_str(&format!("    {},\n", v));
    }
    output.push_str("    LitString,");
    output.push_str("    LitChar,");
    output.push_str("    Literal,");
    output.push_str("}\n\n");

    output.push_str("impl KfTokKind {\n");
    // Conversion from literal
    output.push_str("    pub fn from(s: &str) -> Option<KfTokKind> {\n");
    output.push_str("        match s {\n");
    for (lit, variant) in &from_literal {
        output.push_str(&format!(
            "            {:?} => Some(KfTokKind::{}),\n",
            lit, variant
        ));
    }
    output.push_str("            _ => None,\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // Category functions
    for (kind, list) in &categories {
        let func_name = format!("is_{}", kind);
        output.push_str(&format!(
            "    pub fn {}(&self) -> bool {{\n        matches!(self,\n",
            func_name
        ));
        output.push_str(
            &list
                .iter()
                .map(|v| format!("            KfTokKind::{}", v))
                .collect::<Vec<_>>()
                .join(" | \n"),
        );
        output.push_str("\n        )\n    }\n\n");
    }

    output.push_str("}\n\n");

    // Constants
    // special symbol table
    output.push_str("pub const SPEC_SYMBOLS: &[&str] = &[\n");
    for (i, v) in kinds.iter().enumerate() {
        if v == "symbol" || v == "operator" {
            output.push_str(&format!("   \"{}\", ", &from_literal[i].0));
            if i % 10 == 0 {
                output.push_str("\n");
            }
        }
    }
    output.push_str("\n];\n");

    fs::write(output_f, output).expect("Failed to write lex_def.rs");
}
